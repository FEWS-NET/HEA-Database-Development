# Generated by Django 4.2.2 on 2023-09-03 13:52
import ast
import datetime
import json
import logging
import os
from collections import namedtuple

from django.conf import settings
from django.db import migrations

from common.utils import UnicodeDictReader, get_frozen_treebeard_model

logger = logging.getLogger(__name__)


def forwards(apps, schema_editor):
    ClassifiedProduct = get_frozen_treebeard_model(apps.get_model("common", "ClassifiedProduct"))
    load_cpcv21(ClassifiedProduct)
    update_cpcv2(ClassifiedProduct)
    update_hs2012(ClassifiedProduct)
    update_from_fdw(ClassifiedProduct)
    load_new_products(ClassifiedProduct)
    update_kcals_per_unit(ClassifiedProduct)


def get_prefix(cpc: str) -> str:
    """
    Return the R, L, P or S prefix for a CPC code.
    """
    if cpc == "0" or cpc[:2] == "01":
        return "R"
    elif cpc == "02" or cpc[:3] == "021":
        return "L"
    elif int(cpc[0]) >= 5:
        return "S"
    else:
        return "P"


def load_cpcv21(ClassifiedProduct):
    """
    Load the plain CPC v2.1 data (with the leading R, P, S character)
    """
    logging.info("Loading CPCv2.1 classified products ...")
    #  https://unstats.un.org/unsd/classifications/Econ/Download/In Text/CPC_Ver_2_1_english_structure.txt
    f = os.path.splitext(os.path.abspath(__file__))[0] + "_cpcv21.txt"
    records_added = 0
    records_failed = 0
    with open(f, "r") as f:
        for row in UnicodeDictReader(f, delimiter=";"):
            try:
                if len(row["cpc"]) == 2:
                    ClassifiedProduct.add_root(**row)
                else:
                    if row["cpc"] in ["L02", "P03", "P04"]:
                        parent = ClassifiedProduct.objects.get(pk="R0")
                    elif row["cpc"] in ["P022", "P023", "P024", "P029"]:
                        parent = ClassifiedProduct.objects.get(pk="L02")
                    else:
                        parent = ClassifiedProduct.objects.get(pk=row["cpc"][:-1])
                    parent.add_child(**row)
                records_added += 1
            except Exception as e:
                records_failed += 1
                logging.info(f"{e} for row {row}")
    logging.info("%d records added" % records_added)
    logging.info("%d records failed" % records_failed)


def update_cpcv2(ClassifiedProduct):
    """
    Update the loaded ClassifiedProducts with CPCv2 codes
    """
    logging.info("Updating HS2012 ...")
    # Conversion table
    # https://unstats.un.org/unsd/classifications/Econ/tables/CPC/CPCv21_CPCv2/CPC21-CPC2.txt
    f = os.path.splitext(os.path.abspath(__file__))[0] + "_cpcv2.csv"
    # Store the products in a dict keyed by the official CPC v2.1 code (ie. without the prefix)
    products = {product.pk[1:]: product for product in ClassifiedProduct.objects.all()}
    changed_products = set()
    with open(f, "r") as f:
        for row in UnicodeDictReader(f, delimiter=","):
            cpc = row["CPC21code"].strip()
            cpcv2 = row["CPC2code"].strip()
            cpcv2 = get_prefix(cpcv2) + cpcv2
            if cpc not in products:
                logger.info("Skipping missing CPC v2.1 code %s" % cpc)
                continue
            product = products[cpc]
            if product.cpcv2 is None:
                # Make sure product.cpcv2 can be turned into a set
                product.cpcv2 = [cpcv2]
                changed_products.add(cpc)
            elif cpcv2 not in product.cpcv2:
                product.cpcv2.append(cpcv2)
                changed_products.add(cpc)
    for cpc in changed_products:
        products[cpc].modified = datetime.datetime.now(datetime.timezone.utc)
    ClassifiedProduct.objects.bulk_update([products[cpc] for cpc in changed_products], fields=["cpcv2", "modified"])
    logger.info("%d records updated" % len(changed_products))


def update_hs2012(ClassifiedProduct):
    """
    Update the loaded ClassifiedProducts with HS2012 codes
    """
    logging.info("Updating HS2012 ...")
    # Conversion table
    # https://unstats.un.org/unsd/classifications/Econ/tables/CPC/CPCv21_HS12/cpc21-hs2012.txt
    f = os.path.splitext(os.path.abspath(__file__))[0] + "_hs2012.csv"
    # Store the products in a dict keyed by the official CPC v2.1 code (ie. without the prefix)
    products = {product.pk[1:]: product for product in ClassifiedProduct.objects.all()}
    changed_products = set()

    with open(f, "r") as f:
        for row in UnicodeDictReader(f, delimiter=","):
            cpc = row["CPC21code"].strip()
            hs2012 = row["HS12code"].strip()
            if cpc not in products:
                logger.info("Skipping missing CPC v2.1 code %s" % cpc)
                continue
            product = products[cpc]
            if product.hs2012 is None:
                # Make sure product.hs2012 can be turned into a set
                product.hs2012 = [hs2012]
                changed_products.add(cpc)
            elif hs2012 not in product.hs2012:
                product.hs2012.append(hs2012)
                changed_products.add(cpc)
    for cpc in changed_products:
        products[cpc].modified = datetime.datetime.now(datetime.timezone.utc)
    ClassifiedProduct.objects.bulk_update([products[cpc] for cpc in changed_products], fields=["hs2012", "modified"])
    logger.info("%d records updated" % len(changed_products))


def update_from_fdw(ClassifiedProduct):
    """
    Update the loaded ClassifiedProducts with the common name, scientific_name and aliases from FDW.

    Also load a a select few products that sit below the main CPC hierarchy, to allow us to differentiate the kcals for
    different subtypes of CPC products.
    """
    logging.info("Updating common name, etc. from fdw ...")
    f = os.path.splitext(os.path.abspath(__file__))[0] + "_fdw.csv"
    products = {}
    for product in ClassifiedProduct.objects.all():
        if product.cpcv2 and len(product.cpcv2) == 1:
            products[product.cpcv2[0]] = product
    changed_products = set()
    required_leaf_products = {
        "P21393AA": "P21393AA",  # Cassava Chips
        "P21393AB": "P21393AB",  # Dried Cassava
        "P23120AB": "P23120AB",  # Millet flour
        "P23161AT": "P23161AT",  # Rice, parboiled, lightly milled
        "P23120AA": "P23120AA",  # Sorghum flour
        "R01190AA": "R01199AA",  # Teff, whole grains - note this is the CPCv2 code rather than the CPCv21 code R01199AA
        "P23170AA": "P23170AA",  # Cassava flour
    }
    with open(f, "r", encoding="utf-8-sig") as f:
        for row in UnicodeDictReader(f, delimiter=","):
            aliases = None
            if row["aliases"]:
                aliases = ast.literal_eval(row["aliases"])
                aliases = aliases if aliases else None
            cpcv2 = row["cpcv2"]
            # For some FDW leaf nodes that we need in HEA, copy the record completely
            if cpcv2 in required_leaf_products:
                parent = ClassifiedProduct.objects.get(pk=required_leaf_products[cpcv2][:-2])
                parent.add_child(
                    cpc=required_leaf_products[cpcv2],
                    cpcv2=[cpcv2],
                    description_en=row["description"],
                    common_name_en=row["common_name"],
                    common_name_es=row["es_name"],
                    common_name_fr=row["fr_name"],
                    common_name_pt=row["pt_name"],
                    common_name_ar=row["ar_name"],
                    aliases=aliases or None,
                    hs2012=row["hs2012"],
                    scientific_name=row["scientific_name"],
                )
            # For products that match a CPCv2.1 code update fields not in the
            # original file
            elif cpcv2 in products:
                product = products[cpcv2]
                product.common_name_en = row["common_name"]
                product.common_name_es = row["es_name"]
                product.common_name_fr = row["fr_name"]
                product.common_name_pt = row["pt_name"]
                product.common_name_ar = row["ar_name"]
                product.aliases = aliases or None
                product.scientific_name = row["scientific_name"]
                product.modified = datetime.datetime.now(datetime.timezone.utc)
                changed_products.add(cpcv2)
    ClassifiedProduct.objects.bulk_update(
        [products[cpc] for cpc in changed_products],
        fields=["common_name_en", "scientific_name", "aliases", "modified"],
    )
    logger.info("%d records updated" % len(changed_products))


def load_new_products(ClassifiedProduct):
    """
    Load new products that are required for the kcals table but don't exist in FDW.

    New products are created as leaf nodes below the main CPC hierarchy with a suffix starting with H: HA, HB, etc.
    """
    logging.info("Creating new leaf products ...")
    Product = namedtuple(
        "ClassifiedProduct",
        [
            "cpc",
            "description_en",
            "common_name_en",
            "aliases",
            "common_name_es",
            "common_name_fr",
            "common_name_pt",
            "common_name_ar",
            "hs2012",
            "scientific_name",
        ],
    )
    PRODUCTS = [
        Product("L02111HA", "Cattle, oxen, unspecified", "Oxen", ["ox"], "", "", "", "", "", ""),
        Product(
            "P23130HA", "Groats, meal and pellets of wheat, bulgar wheat", "Bulgur wheat", None, "", "", "", "", "", ""
        ),
        Product(
            "P23130HB", "Groats, meal and pellets of oats, rolled oats", "Rolled oats", None, "", "", "", "", "", ""
        ),
        Product("P23170HA", "Other vegetable flours and meals, yam flour", "Yam flour", None, "", "", "", "", "", ""),
        Product("R01412HA", "Soya beans, other, dry", "Soya beans (dry)", None, "", "", "", "", "", ""),
        Product(
            "R01219HA",
            "Other leafy or stem vegetables, dark green",
            "Leafy vegetables, dark green",
            None,
            "",
            "",
            "",
            "",
            "",
            "",
        ),
        Product(
            "R01219HB",
            "Other leafy or stem vegetables, medium green",
            "Leafy vegetables, medium green",
            None,
            "",
            "",
            "",
            "",
            "",
            "",
        ),
        Product(
            "R01219HC",
            "Other leafy or stem vegetables, light green",
            "Leafy vegetables, light green",
            None,
            "",
            "",
            "",
            "",
            "",
            "",
        ),
        Product(
            "P24490HA",
            "Other non-alcoholic caloric beverages, soft drinks",
            "Soft drinks (commercial)",
            None,
            "",
            "",
            "",
            "",
            "",
            "",
        ),
        Product(
            "P21111HA",
            "Meat of cattle, fresh or chilled, moderate fat",
            "Beef, moderate fat",
            ["beef, mod fat"],
            "",
            "",
            "",
            "",
            "",
            "",
        ),
        Product(
            "P21111HB",
            "Meat of cattle, fresh or chilled, lean",
            "Beef, lean",
            ["beef, lean"],
            "",
            "",
            "",
            "",
            "",
            "",
        ),
        Product(
            "P2224HA", "Butter and other fats and oils derived from milk, ghee", "Ghee", None, "", "", "", "", "", ""
        ),
        Product("P21495HA", "Groundnuts, dry", "Groundnuts (dried)", ["groundnut, dried"], "", "", "", "", "", ""),
        Product(
            "P21495HB",
            "Pumpkin seeds (no coat)",
            "Pumpkin seeds (no coat)",
            ["pumpkin seeds (no coat)"],
            "",
            "",
            "",
            "",
            "",
            "",
        ),
    ]
    for product in PRODUCTS:
        parent = ClassifiedProduct.objects.get(pk=product.cpc[:-2])
        parent.add_child(**product._asdict())
    logger.info("%d records created" % len(PRODUCTS))


def update_kcals_per_unit(ClassifiedProduct):
    """
    Update the records based on the kilocalorie table in to add the kcals_per_unit and unit_of_measure
    """
    logging.info("Updating kcals and unit_of_measure ...")

    f = os.path.splitext(os.path.abspath(__file__))[0] + "_kcal.txt"
    products = {product.pk: product for product in ClassifiedProduct.objects.all()}
    changed_products = set()

    with open(f, "r") as f:
        for row in UnicodeDictReader(f, delimiter=";"):
            cpc = row["cpc"]
            product = products[cpc]
            product.kcals_per_unit = row["kcal_per_kg"]
            product.unit_of_measure_id = row["unit_of_measure"]
            product.modified = datetime.datetime.now(datetime.timezone.utc)
            changed_products.add(cpc)
    ClassifiedProduct.objects.bulk_update(
        [products[cpc] for cpc in changed_products], fields=["kcals_per_unit", "unit_of_measure", "modified"]
    )
    logger.info("%d records updated" % len(changed_products))


def backwards(apps, schema_editor):
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("common", "0007_load_units_of_measure"),
    ]

    operations = [
        migrations.RunPython(forwards, backwards),
    ]
